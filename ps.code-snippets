{
	"ps": {
		"prefix": "ps",
		"body": [
			"#define _USE_MATH_DEFINES",
			"#include<bits/stdc++.h>",
			"#define int long long",
			"using namespace std;",
			"",
			"signed main() {",
			"    cin.tie(0)->sync_with_stdio(0);",
			"",
			"}",
			""
		],
		"description": "ps"
	},
	"scc": {
		"prefix": "scc",
		"body": [
			"struct SCC {",
			"    int n;",
			"    vector<vector<int>> adj;",
			"    vector<int> dfn, scc;",
			"    SCC(int n) :n(n), adj(n + 5) {}",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        adj[v ^ 1].push_back(u ^ 1);",
			"    }",
			"    int dfs(int cur) {",
			"        static stack<int> st;",
			"        static int DFN = 0, SCC = 0;",
			"        st.push(cur);",
			"        int ret = dfn[cur] = ++DFN;",
			"        for (int nxt : adj[cur]) {",
			"            if (!dfn[nxt]) ret = min(ret, dfs(nxt));",
			"            else if (!scc[nxt]) ret = min(ret, dfn[nxt]);",
			"        }",
			"        if (ret == dfn[cur]) {",
			"            ++SCC;",
			"            while (1) {",
			"                int top = st.top();",
			"                st.pop();",
			"                scc[top] = SCC;",
			"                if (top == cur) break;",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"    void getSCC() {",
			"        dfn.assign(n + 5, 0);",
			"        scc.assign(n + 5, 0);",
			"        for (int i = 0; i < n; ++i) {",
			"            if (!scc[i]) dfs(i);",
			"        }",
			"    }",
			"    void atMostOne(vector<int>& v) {",
			"        int m = v.size();",
			"        adj.resize(n + 2 * m);",
			"        addEdge(v[0], n);",
			"        for (int i = 1; i < m; ++i) {",
			"            addEdge(v[i], n + 2 * i);",
			"            addEdge(n + 2 * i - 2, n + 2 * i);",
			"            addEdge(n + 2 * i - 2, v[i] ^ 1);",
			"        }",
			"        n += 2 * m;",
			"    }",
			"    bool sat() {",
			"        getSCC();",
			"        for (int i = 0; i < n / 2; ++i) {",
			"            if (scc[2 * i] == scc[2 * i + 1]) return 0;",
			"        }",
			"        return 1;",
			"    }",
			"    bool isTrue(int i) { return scc[2 * i] < scc[2 * i + 1]; }",
			"};"
		],
		"description": "scc"
	},
	"ahoCorasick": {
		"prefix": "ahoCorasick",
		"body": [
			"struct TRIE {",
			"    struct node {",
			"        int nxt[26];",
			"        bool end;",
			"    };",
			"    vector<node> v;",
			"    TRIE() :v(1) {}",
			"    void push(string& s) {",
			"        int idx = 0;",
			"        for (char x : s) {",
			"            x -= 'a';",
			"            if (!v[idx].nxt[x]) {",
			"                v[idx].nxt[x] = v.size();",
			"                v.emplace_back();",
			"            }",
			"            idx = v[idx].nxt[x];",
			"        }",
			"        v[idx].end = 1;",
			"    }",
			"    void init() {",
			"        queue<pair<int, int>> q;",
			"        for (int x : v[0].nxt) {",
			"            if (x) q.emplace(x, 0);",
			"        }",
			"        while (!q.empty()) {",
			"            auto [idx, prv] = q.front();",
			"            q.pop();",
			"            v[idx].end |= v[prv].end;",
			"            for (int i = 0; i < 26; ++i) {",
			"                if (v[idx].nxt[i]) q.emplace(v[idx].nxt[i], v[prv].nxt[i]);",
			"                else v[idx].nxt[i] = v[prv].nxt[i];",
			"            }",
			"        }",
			"    }",
			"    bool qry(string& s) {",
			"        int idx = 0;",
			"        for (char x : s) {",
			"            idx = v[idx].nxt[x - 'a'];",
			"            if (v[idx].end) return 1;",
			"        }",
			"        return 0;",
			"    }",
			"};",
			""
		],
		"description": "ahoCorasick"
	},
	"crt": {
		"prefix": "crt",
		"body": [
			"using pii = pair<int, int>;",
			"using ti = tuple<int, int, int>;",
			"ti euclid(int a, int b) {",
			"    ti x(1, 0, abs(a));",
			"    ti y(0, 1, abs(b));",
			"    while (get<2>(y)) {",
			"        auto& [a, b, c] = x;",
			"        auto& [d, e, f] = y;",
			"        int q = c / f;",
			"        a -= q * d;",
			"        b -= q * e;",
			"        c -= q * f;",
			"        swap(x, y);",
			"    }",
			"    return x;",
			"}",
			"pii crt(vector<pii>& arr) {",
			"    pii ret(0, 1);",
			"    for (auto& [a, m] : arr) {",
			"        a = (a % m + m) % m;",
			"        auto [x, y, g] = euclid(ret.second, m);",
			"        if ((ret.first - a) % g) return { -1, -1 };",
			"        int n = ret.second * m / g;",
			"        ret.first = m / g * y % n * ret.first % n + ret.second / g * x % n * a % n;",
			"        ret.first = (ret.first % n + n) % n;",
			"        ret.second = n;",
			"    }",
			"    return ret;",
			"}",
			""
		],
		"description": "crt"
	},
	"flow": {
		"prefix": "flow",
		"body": [
			"template<class T>",
			"struct FLOW {",
			"    const T INF = numeric_limits<T>::max();",
			"    struct EDGE {",
			"        int nxt;",
			"        T flow, cap, l;",
			"        EDGE(int nxt, T flow, T cap, T l = 0) :nxt(nxt), flow(flow), cap(cap), l(l) {}",
			"    };",
			"    int n;",
			"    vector<EDGE> edges;",
			"    vector<vector<int>> edgeIdx;",
			"    vector<int> work, lv;",
			"    vector<T> demand;",
			"    FLOW(int n) :n(n), edgeIdx(n + 5), demand(n + 5) {}",
			"    void addEdge(int u, int v, T r, T l = 0) {",
			"        if (r == -1) r = INF;",
			"        demand[u] += l;",
			"        edgeIdx[u].push_back(edges.size());",
			"        edges.emplace_back(v, 0, r - l, l);",
			"        demand[v] -= l;",
			"        edgeIdx[v].push_back(edges.size());",
			"        edges.emplace_back(u, 0, 0, 0);",
			"    }",
			"    bool bfs(int src, int snk) {",
			"        lv.assign(n + 5, 0);",
			"        queue<int> q;",
			"        q.push(src);",
			"        lv[src] = 1;",
			"        while (!q.empty()) {",
			"            int cur = q.front();",
			"            q.pop();",
			"            for (int idx : edgeIdx[cur]) {",
			"                EDGE& e = edges[idx];",
			"                if (e.flow < e.cap && !lv[e.nxt]) {",
			"                    lv[e.nxt] = lv[cur] + 1;",
			"                    q.push(e.nxt);",
			"                }",
			"            }",
			"        }",
			"        return lv[snk];",
			"    }",
			"    T dfs(int cur, int snk, T flow) {",
			"        if (cur == snk) return flow;",
			"        for (int& i = work[cur]; i < edgeIdx[cur].size(); ++i) {",
			"            EDGE& e = edges[edgeIdx[cur][i]];",
			"            if (e.flow < e.cap && lv[e.nxt] == lv[cur] + 1) {",
			"                if (T tmp = dfs(e.nxt, snk, min(flow, e.cap - e.flow))) {",
			"                    e.flow += tmp;",
			"                    edges[edgeIdx[cur][i] ^ 1].flow -= tmp;",
			"                    return tmp;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    T dinic(int src, int snk) {",
			"        T ret = 0;",
			"        while (bfs(src, snk)) {",
			"            work.assign(n + 5, 0);",
			"            while (T tmp = dfs(src, snk, INF)) ret += tmp;",
			"        }",
			"        return ret;",
			"    }",
			"    bool circulation() {",
			"        int src = n;",
			"        int snk = n + 1;",
			"        for (int i = 0; i < src; ++i) {",
			"            if (!demand[i]) continue;",
			"            if (demand[i] > 0) {",
			"                addEdge(i, snk, 0, demand[i]);",
			"                demand[snk] += demand[i];",
			"            }",
			"            else {",
			"                addEdge(src, i, 0, -demand[i]);",
			"            }",
			"        }",
			"        return dinic(src, snk) == demand[snk];",
			"    }",
			"    T lrflow(int src, int snk) {",
			"        addEdge(snk, src, 0, INF);",
			"        if (!circulation()) return -1;",
			"        T ret;",
			"        for (auto it = edgeIdx[src].begin(); it != edgeIdx[src].end(); ++it) {",
			"            if (edges[*it].nxt == snk) {",
			"                ret = -edges[*it].flow;",
			"                edgeIdx[src].erase(it);",
			"                break;",
			"            }",
			"        }",
			"        return ret + dinic(src, snk);",
			"    }",
			"};"
		],
		"description": "flow"
	},
	"mcmf": {
		"prefix": "mcmf",
		"body": [
			"template<class T>",
			"struct MCMF {",
			"    const T INF = numeric_limits<T>::max();",
			"    struct EDGE {",
			"        int nxt;",
			"        T flow, cap, cost;",
			"        EDGE(int nxt, T flow, T cap, T cost) :nxt(nxt), flow(flow), cap(cap), cost(cost){}",
			"    };",
			"    int n;",
			"    vector<EDGE> edges;",
			"    vector<vector<int>> edgeIdx;",
			"    vector<int> work;",
			"    vector<T> dist;",
			"    vector<bool> vst;",
			"    MCMF(int n) :n(n), edgeIdx(n + 5) {}",
			"    void addEdge(int u, int v, T cap, T cost) {",
			"        edgeIdx[u].push_back(edges.size());",
			"        edges.emplace_back(v, 0, cap, cost);",
			"        edgeIdx[v].push_back(edges.size());",
			"        edges.emplace_back(u, 0, 0, -cost);",
			"    }",
			"    bool spfa(int src, int snk) {",
			"        vst.assign(n + 5, 0);",
			"        dist.assign(n + 5, INF);",
			"        queue<int> q;",
			"        q.push(src);",
			"        dist[src] = 0;",
			"        while (!q.empty()) {",
			"            int cur = q.front();",
			"            q.pop();",
			"            vst[cur] = 0;",
			"            for (int idx : edgeIdx[cur]) {",
			"                EDGE& e = edges[idx];",
			"                if (e.flow < e.cap && dist[e.nxt] > dist[cur] + e.cost) {",
			"                    dist[e.nxt] = dist[cur] + e.cost;",
			"                    if (!vst[e.nxt]) {",
			"                        vst[e.nxt] = 1;",
			"                        q.push(e.nxt);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        return dist[snk] != INF;",
			"    }",
			"    T dfs(int cur, int snk, T flow) {",
			"        if (cur == snk) return flow;",
			"        vst[cur] = 1;",
			"        for (int& i = work[cur]; i < edgeIdx[cur].size(); ++i) {",
			"            EDGE& e = edges[edgeIdx[cur][i]];",
			"            if (e.flow < e.cap && !vst[e.nxt] && dist[e.nxt] == dist[cur] + e.cost) {",
			"                if (T tmp = dfs(e.nxt, snk, min(flow, e.cap - e.flow))) {",
			"                    e.flow += tmp;",
			"                    edges[edgeIdx[cur][i] ^ 1].flow -= tmp;",
			"                    return tmp;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    pair<T, T> mcmf(int src, int snk) {",
			"        pair<T, T> ret;",
			"        while (spfa(src, snk)) {",
			"            work.assign(n + 5, 0);",
			"            while (T flow = dfs(src, snk, INF)) {",
			"                ret.first += flow;",
			"                ret.second += flow * dist[snk];",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"};"
		],
		"description": "mcmf"
	},
	"ordered_set": {
		"prefix": "ordered_set",
		"body": [
			"#include <bits/extc++.h>",
			"using namespace __gnu_pbds;",
			"template<typename T>",
			"using ordered_set = tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			""
		],
		"description": "ordered_set"
	},
	"sa": {
		"prefix": "sa",
		"body": [
			"struct SA {",
			"    int n;",
			"    string s;",
			"    vector<int> sa, lcp, rnk;",
			"    SA(string& s) :n(s.size()), s(s) {",
			"        getSA();",
			"        getLCP();",
			"    }",
			"    void csort(int m, int d) {",
			"        vector<int> cnt(m + 5);",
			"        vector<int> idx(n);",
			"        for (int i = 0; i < n; ++i) {",
			"            if (sa[i] + d >= n) idx[i] = 0;",
			"            else idx[i] = rnk[sa[i] + d] + 1;",
			"            ++cnt[idx[i]];",
			"        }",
			"        partial_sum(cnt.begin(), cnt.end(), cnt.begin());",
			"        vector<int> tmp(n);",
			"        for (int i = n - 1; i >= 0; --i) tmp[--cnt[idx[i]]] = sa[i];",
			"        sa = tmp;",
			"    }",
			"    void updt(int d) {",
			"        vector<int> tmp(n);",
			"        tmp[sa[0]] = 0;",
			"        for (int i = 1; i < n; ++i) {",
			"            bool cmp = rnk[sa[i - 1]] != rnk[sa[i]] || sa[i - 1] + d >= n || rnk[sa[i - 1] + d] < rnk[sa[i] + d];",
			"            tmp[sa[i]] = tmp[sa[i - 1]] + cmp;",
			"        }",
			"        rnk = tmp;",
			"    }",
			"    void getSA() {",
			"        sa.resize(n);",
			"        iota(sa.begin(), sa.end(), 0);",
			"        rnk.assign(s.begin(), s.end());",
			"        csort(1 << 8, 0);",
			"        updt(0);",
			"        for (int d = 1; rnk[sa[n - 1]] != n - 1; d <<= 1) {",
			"            int m = rnk[sa[n - 1]];",
			"            csort(m, d);",
			"            csort(m, 0);",
			"            updt(d);",
			"        }",
			"    }",
			"    void getLCP() {",
			"        lcp.assign(n - 1, 0);",
			"        for (int i = 0, j = 0; i < n; ++i, j = max(j - 1, 0ll)) {",
			"            if (rnk[i] == n - 1) continue;",
			"            while (s[i + j] == s[sa[rnk[i] + 1] + j]) ++j;",
			"            lcp[rnk[i]] = j;",
			"        }",
			"    }",
			"};"
		],
		"description": "sa"
	},
	"berlekamp_massey": {
		"prefix": "berlekamp_massey",
		"body": [
			"const int mod = 998244353;",
			"using lint = long long;",
			"lint ipow(lint x, lint p){",
			"    lint ret = 1, piv = x;",
			"    while(p){",
			"        if(p & 1) ret = ret * piv % mod;",
			"        piv = piv * piv % mod;",
			"        p >>= 1;",
			"    }",
			"    return ret;",
			"}",
			"vector<int> berlekamp_massey(vector<int> x){",
			"    vector<int> ls, cur;",
			"    int lf, ld;",
			"    for(int i=0; i<x.size(); i++){",
			"        lint t = 0;",
			"        for(int j=0; j<cur.size(); j++){",
			"            t = (t + 1ll * x[i-j-1] * cur[j]) % mod;",
			"        }",
			"        if((t - x[i]) % mod == 0) continue;",
			"        if(cur.empty()){",
			"            cur.resize(i+1);",
			"            lf = i;",
			"            ld = (t - x[i]) % mod;",
			"            continue;",
			"        }",
			"        lint k = -(x[i] - t) * ipow(ld, mod - 2) % mod;",
			"        vector<int> c(i-lf-1);",
			"        c.push_back(k);",
			"        for(auto &j : ls) c.push_back(-j * k % mod);",
			"        if(c.size() < cur.size()) c.resize(cur.size());",
			"        for(int j=0; j<cur.size(); j++){",
			"            c[j] = (c[j] + cur[j]) % mod;",
			"        }",
			"        if(i-lf+(int)ls.size()>=(int)cur.size()){",
			"            tie(ls, lf, ld) = make_tuple(cur, i, (t - x[i]) % mod);",
			"        }",
			"        cur = c;",
			"    }",
			"    for(auto &i : cur) i = (i % mod + mod) % mod;",
			"    return cur;",
			"}",
			"int get_nth(vector<int> rec, vector<int> dp, lint n){",
			"    int m = rec.size();",
			"    vector<int> s(m), t(m);",
			"    s[0] = 1;",
			"    if(m != 1) t[1] = 1;",
			"    else t[0] = rec[0];",
			"    auto mul = [&rec](vector<int> v, vector<int> w){",
			"        int m = v.size();",
			"        vector<int> t(2 * m);",
			"        for(int j=0; j<m; j++){",
			"            for(int k=0; k<m; k++){",
			"                t[j+k] += 1ll * v[j] * w[k] % mod;",
			"                if(t[j+k] >= mod) t[j+k] -= mod;",
			"            }",
			"        }",
			"        for(int j=2*m-1; j>=m; j--){",
			"            for(int k=1; k<=m; k++){",
			"                t[j-k] += 1ll * t[j] * rec[k-1] % mod;",
			"                if(t[j-k] >= mod) t[j-k] -= mod;",
			"            }",
			"        }",
			"        t.resize(m);",
			"        return t;",
			"    };",
			"    while(n){",
			"        if(n & 1) s = mul(s, t);",
			"        t = mul(t, t);",
			"        n >>= 1;",
			"    }",
			"    lint ret = 0;",
			"    for(int i=0; i<m; i++) ret += 1ll * s[i] * dp[i] % mod;",
			"    return ret % mod;",
			"}",
			"int guess_nth_term(vector<int> x, lint n){",
			"    if(n < x.size()) return x[n];",
			"    vector<int> v = berlekamp_massey(x);",
			"    if(v.empty()) return 0;",
			"    return get_nth(v, x, n);",
			"}",
			"struct elem{int x, y, v;}; // A_(x, y) <- v, 0-based. no duplicate please..",
			"vector<int> get_min_poly(int n, vector<elem> M){",
			"    // smallest poly P such that A^i = sum_{j < i} {A^j \\times P_j}",
			"    vector<int> rnd1, rnd2;",
			"    mt19937 rng(0x14004);",
			"    auto randint = [&rng](int lb, int ub){",
			"        return uniform_int_distribution<int>(lb, ub)(rng);",
			"    };",
			"    for(int i=0; i<n; i++){",
			"        rnd1.push_back(randint(1, mod - 1));",
			"        rnd2.push_back(randint(1, mod - 1));",
			"    }",
			"    vector<int> gobs;",
			"    for(int i=0; i<2*n+2; i++){",
			"        int tmp = 0;",
			"        for(int j=0; j<n; j++){",
			"            tmp += 1ll * rnd2[j] * rnd1[j] % mod;",
			"            if(tmp >= mod) tmp -= mod;",
			"        }",
			"        gobs.push_back(tmp);",
			"        vector<int> nxt(n);",
			"        for(auto &i : M){",
			"            nxt[i.x] += 1ll * i.v * rnd1[i.y] % mod;",
			"            if(nxt[i.x] >= mod) nxt[i.x] -= mod;",
			"        }",
			"        rnd1 = nxt;",
			"    }",
			"    auto sol = berlekamp_massey(gobs);",
			"    reverse(sol.begin(), sol.end());",
			"    return sol;",
			"}",
			"lint det(int n, vector<elem> M){",
			"    vector<int> rnd;",
			"    mt19937 rng(0x14004);",
			"    auto randint = [&rng](int lb, int ub){",
			"        return uniform_int_distribution<int>(lb, ub)(rng);",
			"    };",
			"    for(int i=0; i<n; i++) rnd.push_back(randint(1, mod - 1));",
			"    for(auto &i : M){",
			"        i.v = 1ll * i.v * rnd[i.y] % mod;",
			"    }",
			"    auto sol = get_min_poly(n, M)[0];",
			"    if(n % 2 == 0) sol = mod - sol;",
			"    for(auto &i : rnd) sol = 1ll * sol * ipow(i, mod - 2) % mod;",
			"    return sol;",
			"}"
		],
		"description": "berlekamp_massey"
	},
	"fft": {
		"prefix": "fft",
		"body": [
			"template<class T>",
			"struct FFT {",
			"    using cpx = complex<double>;",
			"    int lg, n;",
			"    vector<int> rev;",
			"    vector<cpx> wn;",
			"    FFT() {}",
			"    void init(int m) {",
			"        lg = __lg(m) + 1;",
			"        n = 1 << lg;",
			"        rev.resize(n);",
			"        wn.resize(n);",
			"        for (int i = 1; i < n; ++i) {",
			"            rev[i] = rev[i >> 1] >> 1 ^ (i & 1) << lg - 1;",
			"        }",
			"        wn[1] = 1;",
			"        for (int i = 1; i < lg; ++i) {",
			"            cpx w = polar(1.0, M_PI / (1 << i));",
			"            for (int j = 1 << i - 1; j < 1 << i; ++j) {",
			"                wn[j << 1] = wn[j];",
			"                wn[j << 1 ^ 1] = wn[j] * w;",
			"            }",
			"        }",
			"    }",
			"    void fft(vector<cpx>& v) {",
			"        for (int i = 0; i < v.size(); ++i) {",
			"            if (i < rev[i]) swap(v[i], v[rev[i]]);",
			"        }",
			"        for (int l = 1; l < n; l <<= 1) {",
			"            for (int i = 0; i < n; i += l << 1) {",
			"                for (int j = 0; j < l; ++j) {",
			"                    cpx even = v[i + j];",
			"                    cpx odd = wn[j + l] * v[i + j + l];",
			"                    v[i + j] = even + odd;",
			"                    v[i + j + l] = even - odd;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    vector<T> conv(vector<int>& a, vector<int>& b) {",
			"        init(a.size() + b.size());",
			"        vector<cpx> in(n), out(n);",
			"        for (int i = 0; i < a.size(); ++i) {",
			"            in[i].real(a[i]);",
			"        }",
			"        for (int i = 0; i < b.size(); ++i) {",
			"            in[i].imag(b[i]);",
			"        }",
			"        fft(in);",
			"        for (cpx& x : in) x *= x;",
			"        for (int i = 0; i < n; ++i) {",
			"            out[i] = in[-i & n - 1] - conj(in[i]);",
			"        }",
			"        fft(out);",
			"        vector<T> ret(n);",
			"        for (int i = 0; i < n; ++i) {",
			"            ret[i] = round(out[i].imag()) / (4 * n);",
			"        }",
			"        return ret;",
			"    }",
			"    vector<T> convMOD(vector<int>& a, vector<int>& b, T MOD) {",
			"        init(a.size() + b.size());",
			"        T cut = sqrt(MOD);",
			"        vector<cpx> f(n), g(n);",
			"        for (int i = 0; i < a.size(); ++i) {",
			"            f[i] = { a[i] % cut, a[i] / cut };",
			"        }",
			"        for (int i = 0; i < b.size(); ++i) {",
			"            g[i] = { b[i] % cut, b[i] / cut };",
			"        }",
			"        fft(f); fft(g);",
			"        vector<cpx> small(n), large(n);",
			"        for (int i = 0; i < n; ++i) {",
			"            int j = -i & n - 1;",
			"            small[i] = (f[j] + conj(f[i])) * g[j] / (2.0 * n);",
			"            large[i] = (f[j] - conj(f[i])) * g[j] / (2.0 * n * 1i);",
			"        }",
			"        fft(small); fft(large);",
			"        vector<T> ret(n);",
			"        for (int i = 0; i < n; ++i) {",
			"            T k0 = round(small[i].real());",
			"            T k1 = round(small[i].imag() + large[i].real());",
			"            T k2 = round(large[i].imag());",
			"            k0 = (k0 % MOD + MOD) % MOD;",
			"            k1 = (k1 % MOD + MOD) % MOD;",
			"            k2 = (k2 % MOD + MOD) % MOD;",
			"            ret[i] = (k2 * cut % MOD * cut % MOD + k1 * cut % MOD + k0) % MOD;",
			"        }",
			"        return ret;",
			"    }",
			"};"
		],
		"description": "fft"
	},
	"hld": {
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"    int n;",
			"    vector<vector<int>> adj;",
			"    vector<int> sz, inDFN, outDFN, par, root;",
			"    HLD(int n) :n(n), adj(n + 5), sz(n + 5), inDFN(n + 5), outDFN(n + 5), par(n + 5), root(n + 5) {}",
			"    void getSz(int cur) {",
			"        sz[cur] = 1;",
			"        for (int nxt : adj[cur]) {",
			"            if (sz[nxt]) continue;",
			"            getSz(nxt);",
			"            sz[cur] += sz[nxt];",
			"            par[nxt] = cur;",
			"        }",
			"    }",
			"    void getDfn(int cur) {",
			"        static int dfn = 0;",
			"        inDFN[cur] = ++dfn;",
			"        int child = 0;",
			"        for (int nxt : adj[cur]) {",
			"            if (!inDFN[nxt] && sz[child] < sz[nxt]) child = nxt;",
			"        }",
			"        if (child) {",
			"            root[child] = root[cur];",
			"            getDfn(child);",
			"        }",
			"        for (int nxt : adj[cur]) {",
			"            if (inDFN[nxt]) continue;",
			"            root[nxt] = nxt;",
			"            getDfn(nxt);",
			"        }",
			"        outDFN[cur] = dfn;",
			"    }",
			"    void solve() {",
			"        getSz(1);",
			"        root[1] = 1;",
			"        getDfn(1);",
			"    }",
			"};"
		],
		"description": "hld"
	},
	"geometry": {
		"prefix": "geometry",
		"body": [
			"using T = int;",
			"using cpx = complex<T>;",
			"istream& operator>>(istream& in, cpx& a) {",
			"    T x, y;",
			"    in >> x >> y;",
			"    a = { x, y };",
			"    return in;",
			"}",
			"T dot(cpx a, cpx b) { return (conj(a) * b).real(); }",
			"T cross(cpx a, cpx b) { return (conj(a) * b).imag(); }",
			"int ccw(cpx a, cpx b, cpx c) {",
			"    T tmp = cross(b - a, c - a);",
			"    return tmp < 0 ? -1 : tmp > 0;",
			"}",
			"bool angCmp(cpx a, cpx b) {",
			"    pair<T, T> o;",
			"    bool A = o < pair<T, T>(a.imag(), a.real());",
			"    bool B = o < pair<T, T>(b.imag(), b.real());",
			"    if (A != B) return B;",
			"    else return ccw(cpx(), a, b) > 0;",
			"}",
			"vector<cpx> convexHull(vector<cpx> arr) {",
			"    swap(arr[0], *min_element(arr.begin(), arr.end(), [](cpx a, cpx b) {",
			"        return pair<T, T>(a.imag(), a.real()) < pair<T, T>(b.imag(), b.real());",
			"        }));",
			"    sort(arr.begin() + 1, arr.end(), [&](cpx a, cpx b) {",
			"        if (int tmp = ccw(arr[0], a, b)) return tmp > 0;",
			"        else return norm(a - arr[0]) < norm(b - arr[0]);",
			"        });",
			"    int m = 0;",
			"    auto ret = arr;",
			"    for (cpx& point : arr) {",
			"        while (m >= 2 && ccw(ret[m - 2], ret[m - 1], point) <= 0) --m;",
			"        ret[m++] = point;",
			"    }",
			"    ret.resize(m);",
			"    return ret;",
			"}",
			"bool intersect(cpx a, cpx b, cpx c, cpx d) {",
			"    pair<T, T> A(a.real(), a.imag()), B(b.real(), b.imag()), C(c.real(), c.imag()), D(d.real(), d.imag());",
			"    if (A > B) swap(A, B);",
			"    if (C > D) swap(C, D);",
			"    if (B < C || D < A) return 0;",
			"    return ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0;",
			"}"
		],
		"description": "geometry"
	}
}
